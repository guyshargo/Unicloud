# -*- coding: utf-8 -*-
"""Copy of hw3- with titles no big data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18fgHvLeaDzJPNGH-kZnDVnLQcYmR4iD4

# **Installation - pip**
"""

!pip install firebase requests beautifulsoup4 nltk --quiet
!pip install ipywidgets
!pip install paho-mqtt

"""# **Imports**"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
from IPython.display import display, clear_output
from ipywidgets import *
import time
import random
import asyncio
from collections import deque
import json
from datetime import datetime
# %matplotlib inline
import pandas as pd

# DB
from firebase import firebase

# Search crawling
import re, nltk, requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor
from nltk.stem import PorterStemmer
from requests.adapters import HTTPAdapter
nltk.download('punkt', quiet=True)

# Chat-Bot
import textwrap
import google.generativeai as genai
from IPython.display import Markdown, update_display

# Sensors
import paho.mqtt.client as mqtt

# Statistics
from datetime import timedelta, datetime
from google.colab import files
import openpyxl

# Big Data
import csv

# Task Manager
from IPython.display import HTML

"""# **Global Variables**"""

# Sensor definitions
indoor_sensors = [
    {"type": "Temperature", "icon": "üå°Ô∏è", "values": deque(maxlen=6), "isShow": True},
    {"type": "Humidity", "icon": "üíß", "values": deque(maxlen=6), "isShow": True},
    {"type": "Pressure", "icon": "üå¨Ô∏è", "values": deque(maxlen=6), "isShow": True},
    {"type": "Distance", "icon": "üìè", "values": deque(maxlen=6), "isShow": True},
]

outdoor_sensors = [
    {"type": "Temperature", "icon": "üå°Ô∏è", "values": deque(maxlen=6)},
    {"type": "Humidity", "icon": "üíß", "values": deque(maxlen=6)},
    {"type": "DLIGHT", "icon": "‚òÄÔ∏è", "values": deque(maxlen=6)},
]

SENSOR_UNITS = {
    "Temperature": "¬∞C", "Humidity": "%", "Pressure": "hPa",
    "Distance": "mm", "DLIGHT": "Lux"
}

IRREGULAR_THRESHOLDS = {
    "Temperature": (20, 30), "Humidity": (60, 80),
    "Pressure": (900, 1030), "Distance": (500, 900),
    "DLIGHT": (1000, 1500)
}

MAX_REG = {
    "Temperature": 30,
    "Humidity":    80,
    "Pressure":   1030,
    "Distance":    900,
    "DLIGHT":     1500,
}

logged_user = None

DB_URL = 'https://hw2-index-default-rtdb.firebaseio.com/'
FBconn = firebase.FirebaseApplication(DB_URL, None)

"""# **Index Preperation**"""

ROOT_URL = "https://mqtt.org/"
MAX_PAGES = 50
CRAWL_DEPTH = 2
THREADS = 32

# Stop words
STOP_WORDS = {
    'a','an','the','and','or','in','on','at','of','to','for','with','by','from',
    'is','are','was','were','be','been','being','it','its','this','that','these','those',
    'as','if','but','so','such','into','about','than','then',
    'mqtt','protocol','client','server'
}

#cut the words to there root
stemmer = PorterStemmer()
session = requests.Session()
adapter = HTTPAdapter(pool_connections=THREADS, pool_maxsize=THREADS)
session.mount("http://", adapter)
session.mount("https://", adapter)

# fetch a single URL and return (url, BeautifulSoup)
def fetch_page(url):
    try:
        r = session.get(url, timeout=4)
        if r.ok and 'text/html' in r.headers.get('content-type',''):
            return url, BeautifulSoup(r.text, 'html.parser')
    #skip any network fai
    except requests.RequestException:
        pass
    return url, None

# whole-site crawl
def crawl(root=ROOT_URL, depth=CRAWL_DEPTH, maxp=MAX_PAGES):
    seen, queue, pages = set(), [(root, 0)], []
    while queue and len(pages) < maxp:
        # pull next batch for the thread-pool
        batch, next_queue = queue[:THREADS], queue[THREADS:]
        queue = next_queue
        with ThreadPoolExecutor(max_workers=THREADS) as ex:
            for url, soup in ex.map(lambda u_d: fetch_page(u_d[0]), batch):
                # current depth
                d = dict(batch)[url]
                seen.add(url)
                if len(pages) >= maxp or soup is None:
                    continue
                # append the page successfully
                pages.append((url, soup))
                if d >= depth:
                    continue
                # enqueue same site hyperlinks for the next wave
                for a in soup.find_all('a', href=True):
                    full = urljoin(url, a['href'])
                    if urlparse(full).netloc == urlparse(root).netloc and full not in seen:
                        queue.append((full, d + 1))
    return pages

# build frequency map of meaningful words inside one BeautifulSoup document
def index_words(soup):
    idx = {}
    for w in re.findall(r'\w+', soup.get_text()):
        w = w.lower()
        if w not in STOP_WORDS:
            idx[w] = idx.get(w, 0) + 1
    return idx

# apply stemming
def stemming(idx):
    out = {}
    for w, c in idx.items():
        root = stemmer.stem(w)
        out[root] = out.get(root, 0) + c
    return out

# build inverted index term‚Üíurls
def build_inv(pages):
    inv = defaultdict(list)
    for url, soup in pages:
        for term in stemming(index_words(soup)):
            inv[term].append(url)
    return inv

pages = crawl()

"""# **Microservices**"""

#Index micro-service
class IndexService:
    def __init__(self):
        # Permanent DB held in memory
        self.documents = {}
        self.index = {}
        self.url2id = {}
        # Remove punctuation and weird chars from words
        self.trans = str.maketrans({'.':'','#':'','$':'','[':'',']':'','/':'',',':'','_':''})

    def add_document(self, doc_data):
        url = doc_data['title']
        # skip if already indexed
        if url in self.url2id:
            return self.documents[self.url2id[url]]

        # assign fresh id
        doc_id = str(len(self.documents) + 1)
        self.url2id[url] = doc_id
        self.documents[doc_id] = {**doc_data, 'id': doc_id}

        # update the inverted index word to doc_ids
        for word in doc_data['content'].lower().split():
            safe = word.translate(self.trans)
            if safe:
                self.index.setdefault(safe, set()).add(doc_id)

        return self.documents[doc_id]

    def get_document(self, doc_id):
        return self.documents.get(doc_id)

    def search_word(self, word):
        word = word.lower()
        return list(self.index.get(word, set()))

# Query micro-service
class QueryService:
    def __init__(self, index_service):
        self.index_service = index_service
        self.queries = {}

    def create_query(self, query_data):
        try:
            query_id = str(len(self.queries) + 1)
            search_terms = query_data['terms']

            # Find matching documents
            results = set()
            for term in search_terms:
                doc_ids = self.index_service.search_word(term)
                if not results:
                    results = set(doc_ids)
                else:
                    results &= set(doc_ids)

            # Save query
            query = {
                'id': query_id,
                'terms': search_terms,
                'results': list(results),
                'timestamp': query_data.get('timestamp', 'now')
            }
            self.queries[query_id] = query
            return query
        except Exception as e:
            return {'error': str(e)}


# Result micro-service
class ResultService:
    def __init__(self, index_service, query_service):
        self.index_service = index_service
        self.query_service = query_service
        self.results = {}

    def format_results(self, query_id):
        query = self.query_service.queries.get(query_id)
        if not query:
            return {'error': 'Query not found'}

        # Build a list with title + first 100 chars
        formatted_results = []
        for doc_id in query['results']:
            doc = self.index_service.get_document(doc_id)
            if doc:
                formatted_results.append({
                    'doc_id': doc_id,
                    'title': doc['title'],
                    'snippet': doc['content'][:100] + '...'
                })

        result_id = str(len(self.results) + 1)
        result = {
            'id': result_id,
            'query_id': query_id,
            'formatted_results': formatted_results,
            'count': len(formatted_results)
        }
        self.results[result_id] = result
        return result

# Us the micro-services
index_service = IndexService()
query_service = QueryService(index_service)
result_service = ResultService(index_service, query_service)

# Crawl the site and feed docs into the index
pages = crawl()
for url, soup in pages:
    index_service.add_document({
        'title': url,
        'content': soup.get_text() if soup else ''
    })

"""# **Search Bar - Logic**"""

#get the common prefix for suggestions
def common_prefix_len(word1, word2):
      i = 0
      while i < min(len(word1), len(word2)) and word1[i] == word2[i]:
          i += 1
      return i
def get_suggestions(prefix):
    # Normalize the full prefix
    full_prefix = prefix.strip().lower()

    # Split the prefix into words and get the last word for suggestion
    words = full_prefix.split()
    if not words:
        return []

    last_word = words[-1].translate(index_service.trans)

    suggestions = []

    # Match suggestions only for the last word
    for word in index_service.index.keys():
        if word.startswith(last_word):
            suggestions.append(word)

    # Sort by prefix match quality
    suggestions = sorted(suggestions, key=lambda w: common_prefix_len(w, last_word), reverse=True)

    return suggestions[:5]

def search_records(query):
  #stip and stem the query
    query = query.strip().lower()
    terms = [stemmer.stem(t) for t in query.split() if t not in STOP_WORDS]
#use query microservice on the stemmed query
    q = query_service.create_query({'terms': terms})
    #use result microservice to refine the result
    formatted = result_service.format_results(q['id'])
    #rand the urls by occurences
    ranked = []
    word_counts = {}
    #go over the results
    for res in formatted['formatted_results']:
        url = res['title']
        #get the document's content from the service
        content = index_service.get_document(res['doc_id'])['content'].lower()
        #count occurnces in the document
        occurrences = 0
        for t in terms:
            occurrences += content.count(t)
        #rank the url by occurences
        rank = 1.0 / occurrences if occurrences > 0 else 0.0
        ranked.append((url, 1 - rank))
        word_counts[url] = occurrences
    return {
        "ranked": ranked,
        "word_counts": word_counts,
        "suggestions": []
    }

"""# **Chat-Bot - Preperation**"""

# --- Configuration ---
genai.configure(api_key='AIzaSyDHStM2VXxEakUGCuA2E9IgHDZ9XqvxM74')  # Insert your API key here
model = genai.GenerativeModel('gemini-1.5-flash')

# --- Markdown Formatter ---
def to_markdown(text):
    text = text.replace('‚Ä¢', ' *')
    return Markdown(textwrap.indent(text, '> ', predicate=lambda _: True))

# --- Prompt Template ---
def build_prompt(user_question):
    return f"""
You are a virtual helper assistant for a smart dashboard system used to monitor sensors and manage workers and tasks.
Your role is to assist users (admins and workers) in understanding and using the system efficiently.

If the question is related to sensors, their values, units, communication protocols (like MQTT), or any related technical term ‚Äî you may use information from https://mqtt.org/ to explain relevant concepts.

The system includes the following tabs:

---

 Dashboard Tab:
- Shows the latest values from all indoor and outdoor sensors.
- Displays alerts for irregular sensor values.

---

 Search Tab:
- Contains a search bar that looks up and suggests links from: https://mqtt.org/ (ROOT_URL).
- Helps users find relevant MQTT-related content or sensor documentation.

---

Task Manager Tab:
- Admins can:
  - Add new tasks.
  - Assign tasks to workers.
  - Delete tasks.
  - Change task statuses.
  - Filter and view all tasks by name, status, or priority.
  - can aproove completed tasks
  -set score for each task

- Workers can:
  - View only their assigned tasks.
  - Change task status to "To Do" or "In Progress".
- Each task has a score value; completing a task adds that score to the worker.



---

Statistics Tab:
- Given a selected time range, the system calculates and displays:
  - Total average
  - Normalized average
  - Percentage difference from the first average
  - Difference in normalized values for pressure and temperature
  - Difference between temperature and humidity
- The statistical data can be exported to Excel via the export button.

---

Sensors Tab:
- The system includes two types of sensors:

Indoor sensors: Temperature, Humidity, Pressure, Distance
Outdoor sensors: Temperature, Humidity, DLIGHT

Sensor Units:
SENSOR_UNITS = {{
    "Temperature": "¬∞C",
    "Humidity": "%",
    "Pressure": "hPa",
    "Distance": "mm",
    "DLIGHT": "Lux"
}}

Irregular Thresholds:
IRREGULAR_THRESHOLDS = {{
    "Temperature": (20, 30),
    "Humidity": (60, 80),
    "Pressure": (900, 1030),
    "Distance": (500, 900),
    "DLIGHT": (1000, 1500)
}}

- The sensor system is based on the MQTT protocol.

Additional features in the Sensors Tab:
- Sensors can be refreshed via the "Refresh" button.
- Graphs show each sensor's values over time.
- graph becomes red if the last value is irregular
- graph becomes green if the last value is in normal range
- Admins can choose which sensors are visible to employees.

---

Store Tab:
- Workers can use their score points (from task completions) to redeem gifts.
- A leaderboard ranks all workers by score.
- in this tab you can see all of the gifts
- worker can choose to purchase gifts by their score points by clicking on the item's dropbox
- the dropbox shows only the items they can purchase with the workers score
- the gifts are enabled according to the score points the worker has
- worker can view how many points he has
---

Login Tab:
- Allows login with either email or username and password.
- Supports both Admin and Worker roles.
- Also includes the Logout functionality.

---

Now, based on the system above, answer the following question in a helpful, clear, and professional manner:

User's question: "{user_question}"
"""

"""# **Tab 2 - Search Bar**"""

# Tab 2: Search
tab2_content = widgets.Output()

# Search input field
search_input = widgets.Text(
    placeholder="üîç Type to search...",
    layout=widgets.Layout(width="500px", margin="0 10px 0 0")
)

# Search button
search_button = widgets.Button(
    description="Search",
    button_style="success",
    layout=widgets.Layout(width="100px")
)

# Suggestion output area
suggestions_output = widgets.Output()

# Search box layout
search_box = HBox([search_input, search_button])

# Function to handle search
def search_data(_=None):
    query = search_input.value.strip().lower()

    with tab2_content:
        tab2_content.clear_output(wait=True)
        suggestions_output.clear_output(wait=True)
        display(search_box, suggestions_output)
        #loading print
        print("\nüîç Searching pages...", flush=True)
        #search using search record function
        result = search_records(query)
        #recive the relevent urls and suggestions
        relevant_urls = result["ranked"]
        occurrences = result["word_counts"]
        suggestions = result["suggestions"]
        #clear output
        tab2_content.clear_output(wait=True)
        suggestions_output.clear_output(wait=True)
        #display the search box and suggestion output
        display(search_box, suggestions_output)
        #the search query
        print(f"\nüîç You searched for: \"{query}\"", flush=True)
        #if relvent urls exist
        if relevant_urls:
          #print each url with the occurences and rank
            print(f"\n Found {len(relevant_urls)} Results\n" + "-" * 50)
            for url, score in relevant_urls:
                print(f"üîó {url}")
                print(f"    üìä Occurrences: {occurrences.get(url, 0)} | Page Rank: {score:.4f}")
                print("-" * 50)
        else:
          #if no results found
            print("\n‚ùå No results found.")
            #print suggestions
            if suggestions:
                print("\nüí° Did you mean:")
                for s in suggestions:
                    # Create a button for each suggestion
                    btn = widgets.Button(description=s, layout=widgets.Layout(width='auto'))
                    btn.style.button_color = '#f0f0f0'
                    #on click on suggestions btn
                    def on_click_handler(b, value=s):
                            search_input.value = value
                    btn.on_click(on_click_handler)
                    display(btn)

# Function to handle real-time suggestions
def update_suggestions(change):
    query = search_input.value.strip().lower()
    with suggestions_output:
        suggestions_output.clear_output(wait=True)
        if query:
          #get suggestions using the get suggestion function from search logic
            suggestions = get_suggestions(query)
            #print each suggestion
            if suggestions:
                print("üí° Suggestions:")
                for s in suggestions:
                    # Create a button for each suggestion
                    btn = widgets.Button(description=s, layout=widgets.Layout(width='auto'))
                    btn.style.button_color = '#f0f0f0'
                    #on click on suggestions btn
                    def on_click_handler(b, value=s):
                          original = search_input.value.strip()
                          parts = original.split()
                      #   Replace only the last word with the suggestion
                          if parts:
                            parts[-1] = value  # Replace last word
                            search_input.value = ' '.join(parts)
                          else:
                            search_input.value = value
                    btn.on_click(on_click_handler)
                    display(btn)
        else:
            print("")
# Hook search and suggestions
search_button.on_click(search_data)
search_input.observe(update_suggestions, names='value')

# Initial display
with tab2_content:
    display(search_box, suggestions_output)

"""# **Tab 1 - Dashboard**"""

""" Tab1: Dashboard """
def load_dashboard():
    global tab1_content
    tab1_content.clear_output()  # Clear previous content
    with tab1_content:
        row_alert = create_outliers_alert()
        row1 = create_latest_sensors()
        row1.layout = widgets.Layout(flex='1 1 auto')
        row_alert.layout = widgets.Layout(width='320px', margin='0 0 0 20px')
        chatbot = createChatBot()
         # Set widths to 1/3 of the parent
        chatbot.layout = widgets.Layout(width='67%')
        row1.layout = widgets.Layout(width='33.33%')
        row_alert.layout = widgets.Layout(width='20%', margin='0')
        #create top row
        top_row = widgets.HBox(
            [chatbot, row1, row_alert],
            layout=widgets.Layout(align_items='flex-start', width='100%',gap = '10px')
        )

        # Display
        display(widgets.VBox([top_row]))

""" Get the latest sensor data from the database """
def get_sensor_latest_value():
    sensor_data = []
    sensor_model = {
        "location": None,
        "type": None,
        "latest_value": None,
        "timestamp": None,
        "unit": None,
        "is_irregular": None
    }

    try:
        result = FBconn.get('/Sensors/', None)
        for location in result.keys():
            for sensor_type, sensor_info in result[location].items():
                sensor_copy = sensor_model.copy()
                latest_enter = sensor_info['latest']

                irregulars = sensor_info.get('outliers', None)
                latest_irregular = irregulars[list(irregulars)[-1]] if irregulars else None
                if latest_irregular and latest_irregular['value'] == latest_enter['value'] and latest_irregular['timestamp'] == latest_enter['timestamp']:
                    sensor_copy['is_irregular'] = True
                else:
                    sensor_copy['is_irregular'] = False

                sensor_copy['location'] = location
                sensor_copy['type'] = sensor_type
                sensor_copy['unit'] = SENSOR_UNITS[sensor_type]
                sensor_copy['latest_value'] = latest_enter['value']
                sensor_copy['timestamp'] = latest_enter['timestamp']
                sensor_data.append(sensor_copy)

    except Exception as e:
        print(f"Error getting sensors: {e}")
    return sensor_data

""" Create the latest sensors """
def create_latest_sensors():
    sensor_latest_data = get_sensor_latest_value()

    rows = []
    current_row = []
    for i, sensor_latest in enumerate(sensor_latest_data):
        current_row.append(create_dashboard_sensor_card(sensor_latest))

        # Create a new row after every 4 cards or at the end
        if len(current_row) == 4 or i == len(sensor_latest_data) - 1:
            row = widgets.HBox(current_row, layout=widgets.Layout(
                display='flex',
                flex_flow='row wrap',
                justify_content='center',
                align_items='center'
            ))
            rows.append(row)
            current_row = []

    return widgets.VBox(rows, layout=widgets.Layout(
        display='flex',
        flex_flow='column',
        align_items='center'
    ))

""" Create the sensor card """
def create_dashboard_sensor_card(latest_value):
    size_model = {
        'name': 16,
        'value': 24,
        'timestamp': 10,
        'location': 16
    }

    color = '#99CC99' if not latest_value['is_irregular'] else '#FF6666'

    sensor_name = latest_value['type']
    value = f"{latest_value['latest_value']} {latest_value['unit']}"
    timestamp = f"{latest_value['timestamp'] if latest_value['timestamp'] else ''}"

    # Create HTML for the circular card
    html = f"""
    <div style="
        width: 170px;
        height: 170px;
        border-radius: 10%;
        background-color: {color};
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        padding: 10px;
        margin: 10px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        border: 4px solid black;
    ">
        {get_sensor_latest_label(latest_value['location'], size_model['location'], 'black')}
        {get_sensor_latest_label(sensor_name, size_model['name'], 'white')}
        {get_sensor_latest_label(value, size_model['value'], 'white')}
        {get_sensor_latest_label(timestamp, size_model['timestamp'], 'black')}
    </div>
    """
    return widgets.HTML(html)

""" Create the HTML for the latest sensor data """
def get_sensor_latest_label(value, size, color):
    return f"""
    <div style="
        font-size: {size}px;
        font-weight: bold;
        color: {color};
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    ">{value}</div>
    """

def get_recent_outliers(limit=10):
    """Return the newest <limit> outlier records across *all* sensors."""
    outlier_rows = []

    try:
        res = FBconn.get('/Sensors/', None)  # whole tree
        for loc, sensors in res.items():
            for s_type, info in sensors.items():
                for _id, rec in info.get('outliers', {}).items():
                    outlier_rows.append({
                        "location":  loc,
                        "type":      s_type,
                        "value":     rec['value'],
                        "timestamp": rec['timestamp'],
                    })
        # newest-first (timestamps are HH:MM:SS strings so simple sort works)
        outlier_rows.sort(key=lambda r: r['timestamp'], reverse=True)
    except Exception as e:
        print("‚ö†Ô∏è  Firebase outlier fetch error:", e)

    return outlier_rows[:limit]        # will return <limit> or fewer

def create_outliers_alert():
    rows = get_recent_outliers(10)     # ‚Üê NEW

    if not rows:                       # nothing weird
        return widgets.HTML(
            "<div style='color:green;font-weight:bold;padding:6px'>‚úÖ No outliers detected</div>"
        )

    lis = "".join(
        f"<li>{r['timestamp']} ‚Äì {r['location']} {r['type']}: "
        f"{r['value']} {SENSOR_UNITS[r['type']]}</li>"
        for r in rows
    )

    html = f"""
    <div style='border:2px solid red;border-radius:8px;background:#FFECEC;
                padding:10px;margin-bottom:10px'>
        <h3 style='color:red;margin:0 0 6px 0'>‚ö†Ô∏è Outlier Alerts (latest {len(rows)})</h3>
        <ul style='margin:0 0 0 18px;color:#B20000;font-weight:bold'>
            {lis}
        </ul>
    </div>
    """
    return widgets.HTML(html)
#chat bot creation
def createChatBot():
      chatbot_title = widgets.HTML("<h2 style='margin-bottom: 5px;'>ü§ñ Virtual Chat Bot Assistant</h2>")
      #nput boc=x for user input
      chatbot_input_box = widgets.Text(
      placeholder='Ask Me A Question...',
      layout=widgets.Layout(width='400px', max_width='400px')
      )
      #send button for sending the question
      chatbot_send_button = widgets.Button(
      description='Send',
      button_style='primary',
      layout=widgets.Layout(width='100px', max_width='100px')
      )
      #clear button for clear chat
      chatbot_clear_button = widgets.Button(
      description='Clear Chat',
      button_style='warning',
      layout=widgets.Layout(width='100px', max_width='100px', margin='0 0 0 10px')
      )
      #output message area
      chatbot_output_area = widgets.Output(
      layout=widgets.Layout(
          height='300px',
          width='800px',
          overflow_y='auto',
          border='1px solid #ccc',
          padding='10px'
      )
      )

      #gets user input and displayes virtual assitant answer
      def handle_input(_=None):
          #user input
          user_input = chatbot_input_box.value.strip()
          if not user_input:
              return
          chatbot_input_box.value = ''
          with chatbot_output_area:
                print(f"üë§ {user_input}")
                #building and sendiing the prompt with the user question
                prompt = build_prompt(user_input)
                #getting the ai response
                response = model.generate_content(prompt)
                answer_text = response.text
            #displaying response
          with chatbot_output_area:
                print("ü§ñ Assistant's Answer:")
                display(to_markdown(answer_text))

      #clearing chat output
      def clear_chatbot_area(_=None):
          chatbot_output_area.clear_output()
      #send button on click
      chatbot_send_button.on_click(handle_input)
      #when enter is clicked send the message
      chatbot_input_box.on_submit(handle_input)
      #clear button on click
      chatbot_clear_button.on_click(clear_chatbot_area)

      #chat bot content
      chatbot_display_content = widgets.VBox([
      chatbot_title,
      widgets.HBox([chatbot_input_box, chatbot_send_button, chatbot_clear_button]),
      chatbot_output_area
      ])

      return chatbot_display_content


# Tab 1: Dashboard
tab1_content = widgets.Output()
load_dashboard()

"""# **Tab 5 - Overall Sensors Page**"""

mqtt_connected = {"indoor": False, "outdoor": False}
last_mqtt_received = {"indoor": 0, "outdoor": 0}
sensor_widgets = {}
sensor_titles = {}

# Sensor card with toggle
def create_sensor_card(sensor_type, icon, location):
    key = f"{location}_{sensor_type}"
    unit = SENSOR_UNITS.get(sensor_type, "")
    title = widgets.HTML(f"<h4 style='margin:0;color:gray'>{icon} {sensor_type} (-- {unit})</h4>")
    sensor_titles[key] = title
    graph = widgets.Output()
    sensor_widgets[key] = graph

    # Load 'isShow' from Firebase
    try:
        is_show = FBconn.get(f'/Sensors/{location}/{sensor_type}/isShow', None)
        if is_show is None:
            is_show = True
    except Exception as e:
        print(f"Error fetching isShow for {location}/{sensor_type}: {e}")
        is_show = True

    # Update the local sensor object
    for sensor in (indoor_sensors if location == "indoor" else outdoor_sensors):
        if sensor["type"] == sensor_type:
            sensor["isShow"] = is_show
            break
    # Toggle Seen button
    toggle_btn = widgets.ToggleButton(
        value=is_show,
        description=f'üëÅÔ∏è Show to employee: {"ON" if is_show else "OFF"}',
        button_style='success' if is_show else 'danger',
        layout=widgets.Layout(width='180px', height='30px')
    )

    def toggle_handler(change):
        for sensor in (indoor_sensors if location == "indoor" else outdoor_sensors):
            if sensor["type"] == sensor_type:
                sensor["isShow"] = toggle_btn.value
                toggle_btn.description = f"üëÅÔ∏è Show to employee: {'ON' if toggle_btn.value else 'OFF'}"
                toggle_btn.button_style = 'success' if toggle_btn.value else 'danger'
                try:
                    FBconn.put(f'/Sensors/{location}/{sensor_type}', 'isShow', toggle_btn.value)
                except Exception as e:
                    print(f"Firebase update error: {e}")
                break
        refresh_worker_sensors()

    toggle_btn.observe(toggle_handler, names='value')

    controls = widgets.HBox([title, toggle_btn], layout=widgets.Layout(justify_content="space-between"))
    return widgets.VBox([controls, graph], layout=widgets.Layout(border="1px solid lightgray", padding="10px", border_radius="12px", width="100%", height="330px"))

# Live plot function
def plot_sensor(key, sensor_type, x, y):
    if not y:
        sensor_titles[key].value = f"<h4 style='margin:0;color:gray'>{sensor_type} (-- {SENSOR_UNITS[sensor_type]})</h4>"
        return

    avg = sum(y) / len(y)
    color = '#FF3232' if avg < IRREGULAR_THRESHOLDS[sensor_type][0] or avg > IRREGULAR_THRESHOLDS[sensor_type][1] else '#00C717'
    latest_value = y[-1]
    sensor_titles[key].value = f"<h3 style='margin:0;color:gray'>{sensor_type} ({latest_value} {SENSOR_UNITS[sensor_type]})</h3>"

    with sensor_widgets[key]:
        clear_output(wait=True)
        fig, ax = plt.subplots(figsize=(4.5, 2.5))
        ax.plot(range(len(x)), y, color=color, linewidth=2, marker='o')
        ax.set_xticks(range(len(x)))
        ax.set_xticklabels(x, rotation=30)
        ax.grid(True)
        plt.tight_layout()
        plt.show()
        plt.close()

# Firebase write
def handle_sensor_value(sensor, location, value, now):
    sensor_type = sensor["type"]
    sensor["values"].append((now, value))
    try:
        FBconn.post(f'/Sensors/{location}/{sensor_type}/history', {"timestamp": now, "value": value})
        FBconn.put(f'/Sensors/{location}/{sensor_type}', "latest", {"timestamp": now, "value": value})
        min_val, max_val = IRREGULAR_THRESHOLDS[sensor_type]
        if value < min_val or value > max_val:
            FBconn.post(f'/Sensors/{location}/{sensor_type}/outliers', {"timestamp": now, "value": value})
    except Exception as e:
        print(f"Firebase error ({sensor_type}):", e)

    key = f"{location}_{sensor_type}"
    avg = sum(v for _, v in sensor["values"]) / len(sensor["values"])
    color = '#FF3232' if avg < IRREGULAR_THRESHOLDS[sensor_type][0] or avg > IRREGULAR_THRESHOLDS[sensor_type][1] else '#00C717'
    sensor_titles[key].value = f"<h4 style='margin:0;color:{color}'>{sensor_type} ({value} {SENSOR_UNITS[sensor_type]})</h4>"

def unpack_values(sensor):
      x, y = zip(*sensor["values"])
      x = [ts[-8:] for ts, _ in sensor["values"]]  # Keep only HH:MM:SS
      y = [val for _, val in sensor["values"]]

      return x,y

def proccess_plot():
    for sensor in indoor_sensors:
        if sensor["values"]:
          x, y = unpack_values(sensor)
          plot_sensor(f"indoor_{sensor['type']}", sensor["type"], x, y)
    for sensor in outdoor_sensors:
        if sensor["values"]:
          x, y = unpack_values(sensor)
          plot_sensor(f"outdoor_{sensor['type']}", sensor["type"], x, y)

# Simulated fallback data if sensors connection fail
def simulate_data(sensor_group, location):
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    for sensor in sensor_group:
        sensor_type = sensor["type"]
        simulated_values = {
            "Temperature": round(random.uniform(18, 32), 2),
            "Humidity": random.randint(55, 85),
            "Pressure": random.randint(850, 1040),
            "Distance": random.randint(450, 950),
            "DLIGHT": random.randint(950, 1550)
        }
        if sensor_type in simulated_values:
            value = simulated_values[sensor_type]
            handle_sensor_value(sensor, location, value, now)

# MQTT
def on_message(client, userdata, msg):
    try:
        data = json.loads(msg.payload.decode())
        now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        topic = msg.topic.lower()
        group = indoor_sensors if "indoor" in topic else outdoor_sensors
        location = "indoor" if "indoor" in topic else "outdoor"
        mqtt_connected[location] = True
        last_mqtt_received[location] = time.time()
        for sensor in group:
            if sensor["type"] in data:
                value = float(data[sensor["type"]])
                handle_sensor_value(sensor, location, value, now)
    except Exception as e:
        print("MQTT Error:", e)

def start_mqtt(topic):
    try:
        client = mqtt.Client()
        client.on_message = on_message
        client.connect("test.mosquitto.org", 1883, 60)
        client.subscribe(f"braude/D106/{topic}")
        print(f"Subscribed to MQTT topic: {topic}")
        client.loop_start()
        return True
    except Exception as e:
        print("MQTT connect error:", e)
        return False

# Main async loop
async def sensor_dashboard_loop():
    start_mqtt("indoor")
    start_mqtt("outdoor")
    while True:
        now = time.time()
        # Check if reciving data from sensors
        if now - last_mqtt_received["indoor"] > 5:
            mqtt_connected["indoor"] = False
        if now - last_mqtt_received["outdoor"] > 5:
            mqtt_connected["outdoor"] = False

        # Stiumulate data if not reciving data from sensors
        if not mqtt_connected["indoor"]:
            simulate_data(indoor_sensors, "indoor")
        if not mqtt_connected["outdoor"]:
            simulate_data(outdoor_sensors, "outdoor")

        proccess_plot()

        await asyncio.sleep(10)

# UI layout
indoor_grid = widgets.GridBox(
    children=[create_sensor_card(s["type"], s["icon"], "indoor") for s in indoor_sensors],
    layout=widgets.Layout(grid_template_columns='repeat(2, 1fr)', gap="20px")
)

outdoor_grid = widgets.GridBox(
    children=[create_sensor_card(s["type"], s["icon"], "outdoor") for s in outdoor_sensors],
    layout=widgets.Layout(grid_template_columns='repeat(2, 1fr)', gap="20px")
)

refresh_button = widgets.Button(description="‚ñ∂Ô∏è Refresh", button_style='success')
refresh_status = widgets.HTML("")
dashboard_task = None

def refresh_handler(b):
    global dashboard_task
    if dashboard_task is None or dashboard_task.done():
        dashboard_task = asyncio.create_task(sensor_dashboard_loop())

        time = datetime.now()

        # wait 5 seconds without sleep function
        while (datetime.now() - time).seconds < 6:
            refresh_status.value = "<p style='color:gray'>‚è≥ Refreshing data...</p>"


        dashboard_task.cancel()
        now = datetime.now().strftime('%H:%M:%S')
        refresh_status.value = f"<p style='color:gray'>‚úÖ Last refresh at <b>{now}</b></p>"
        proccess_plot()

    # refresh dashboard sensors
    load_dashboard()

    # refresh workers sensors
    refresh_worker_sensors()


refresh_button.on_click(refresh_handler)

controls = widgets.HBox([refresh_button])
tab5_content = widgets.VBox([
    widgets.HTML(f"<h2 style='margin:0;color:gray'>üè† Indoor Sensors</h2>"),
    indoor_grid,
    widgets.HTML(f"<h2 style='margin:0;color:gray'>üå§Ô∏è Outdoor Sensors</h2>"),
    outdoor_grid,
    controls,
    refresh_status
])

asyncio.create_task(sensor_dashboard_loop())

import requests



def trim_to_latest_sensor_values(max_values=150):
    try:
        sensors_data = requests.get(f"{DB_URL}/Sensors.json").json()
        if not sensors_data:
            print("No sensors found.")
            return

        for location, sensors in sensors_data.items():
            for sensor_type in sensors:
                for section in ['history', 'outliers']:
                    path = f"Sensors/{location}/{sensor_type}/{section}"
                    data = requests.get(f"{DB_URL}/{path}.json").json()

                    if not data or len(data) <= max_values:
                        continue

                    # Sort keys in insertion order (Firebase keys are time-ordered)
                    sorted_keys = sorted(data.keys())
                    keys_to_delete = sorted_keys[:-max_values]

                    # Batch delete
                    delete_payload = {key: None for key in keys_to_delete}
                    res = requests.patch(f"{DB_URL}/{path}.json", json=delete_payload)

                    if res.status_code == 200:
                        print(f"[{location}/{sensor_type}/{section}] Deleted {len(keys_to_delete)} oldest entries.")
                    else:
                        print(f"Failed to delete from {path} ‚Üí {res.text}")

    except Exception as e:
        print("Error during trimming:", e)
trim_to_latest_sensor_values()

"""# **Tab 3 - Statistics Page**"""

# Tab 3: Statistics
# Constants
x_range = 25
step = 4

# Color map for the graphs
colorMap = {
    # RED
    'Temperature-indoor': {
        'average': '#FF0000',
        'normalized': '#FF6666',
        'absolute': '#FF9999'
    },
    # PINK
    'Temperature-outdoor': {
        'average': '#FF00FF',
        'normalized': '#FF66FF',
        'absolute': '#FF99FF'
    },
    # BLUE
    'Humidity-indoor': {
        'average': '#0066CC',
        'normalized': '#66B2FF',
        'absolute': '#99CCFF'
    },
    # BROWN
    'Humidity-outdoor': {
        'average': '#8B4513',
        'normalized': '#B86A2B',
        'absolute': '#D99044'
    },
    # GREEN
    'Pressure-indoor': {
        'average': '#009900',
        'normalized': '#66CC66',
        'absolute': '#99CC99'
    },
    # PURPLE
    'Distance-indoor': {
        'average': '#800080',
        'normalized': '#B366FF',
        'absolute': '#D999FF'
    },
    # YELLOW
    'DLIGHT-outdoor': {
        'average': '#FFD700',
        'normalized': '#FFE44D',
        'absolute': '#FFEB99'
    },
    # GRAY
    'Default': '#FEFEFE'
}

""" Get sensors with date range filter """
def get_sensor_data(start_date=None, end_date=None):
    sensor_data = []
    sensor_model = {
        "type": None,
        "values": [],
        "timestamps": []
    }

    try:
        result = FBconn.get('/Sensors/', None)
        for location in result.keys():
            for sensor_type, sensor_info in result[location].items():
                sensor_copy = sensor_model.copy()
                sensor_copy['type'] = sensor_type + '-' + location

                # Reset arrays for each sensor
                sensor_copy['values'] = []
                sensor_copy['timestamps'] = []

                for _, record in sensor_info['history'].items():
                    try:
                        timestamp = record['timestamp']
                        try:
                            # Try full datetime format
                            record_date = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S')
                        except ValueError:
                            try:
                                # Try date only format
                                record_date = datetime.strptime(timestamp, '%Y-%m-%d')
                            except ValueError:
                                try:
                                    # Try time only format (assume today's date)
                                    time_only = datetime.strptime(timestamp, '%H:%M:%S').time()
                                    record_date = datetime.combine(datetime.now().date(), time_only)
                                except ValueError:
                                    continue

                        # Apply date filter if dates are provided
                        if start_date and end_date:
                            if start_date <= record_date.date() <= end_date:
                                sensor_copy['values'].append(record['value'])
                                sensor_copy['timestamps'].append(record_date)
                        else:
                            sensor_copy['values'].append(record['value'])
                            sensor_copy['timestamps'].append(record_date)
                    except Exception as e:
                        print(f"Error processing record: {e}")
                        continue

                sensor_data.append(sensor_copy)
    except Exception as e:
        print(f"Error getting sensors: {e}")
    return sensor_data

""" Create the checkboxes """
def create_checkboxes():
    # Get unique sensor types
    sensor_types = []
    for sensor in indoor_sensors:
        sensor_types.append(sensor['type'] + '-indoor')

    for sensor in outdoor_sensors:
        sensor_types.append(sensor['type'] + '-outdoor')

    # Create checkboxes for each sensor type
    check_options = {sensor: widgets.Checkbox(value=True, description=sensor) for sensor in sensor_types}
    all_option = widgets.Checkbox(value=True, description='All')

    def all_checkbox_option(event):
        value = event.new
        for checkbox in check_options.values():
            checkbox.value = value

    all_option.observe(all_checkbox_option, names='value')

    # Create the HBox with all checkboxes
    checkboxes = widgets.HBox([all_option] + list(check_options.values()))
    return checkboxes

""" Export the data to an excel file """
def export_to_excel(sensor_types, start_date=None, end_date=None):
    if not sensor_types:
        print("No sensors selected for export")
        return

    # Create Excel file
    now = datetime.now()
    timestamp = f"{now.day}{now.month}{now.year}_{now.hour}:{now.minute}:{now.second}"
    filename = f"sensor_statistics_{timestamp}.xlsx"

    try:
        # Get all sensor data once
        sensor_data = get_sensor_data(start_date, end_date)

        # Pre-calculate all statistics for each sensor
        sensor_stats = {}
        for sensor_type in sensor_types:
            for sensor in sensor_data:
                if sensor["type"] == sensor_type:
                    averages, timestamps = average_by_x_values(sensor['values'], sensor['timestamps'])
                    normalized, _ = calculate_normalized_changes(sensor['values'], sensor['timestamps'])
                    absolute, _ = calculate_absolute_changes(sensor['values'], sensor['timestamps'])
                    sensor_stats[sensor_type] = {
                        'averages': averages,
                        'normalized': normalized,
                        'absolute': absolute,
                        'timestamps': timestamps,
                        'colors': colorMap[sensor_type]
                    }
                    break

        with pd.ExcelWriter(filename, engine='openpyxl') as writer:
            # Create a new workbook and worksheet
            workbook = writer.book
            worksheet = workbook.create_sheet('Sensor Statistics')

            # Write date range if provided
            if start_date and end_date:
                worksheet.cell(row=1, column=1, value=f"Date Range: {start_date} to {end_date}")
                worksheet.merge_cells(start_row=1, start_column=1, end_row=1, end_column=4)
                start_row = 3
            else:
                start_row = 1

            # Write headers and data in batches
            col = 1
            for i, sensor_type in enumerate(sensor_types):
                if sensor_type not in sensor_stats:
                    continue

                stats = sensor_stats[sensor_type]
                colors = stats['colors']

                # Add a spacer column between sensor types (except before the first one)
                if i > 0:
                    worksheet.merge_cells(start_row=start_row, start_column=col, end_row=start_row+26, end_column=col)
                    cell = worksheet.cell(row=start_row, column=col)
                    cell.value = ""
                    cell.fill = openpyxl.styles.PatternFill(start_color="E0E0E0", end_color="E0E0E0", fill_type="solid")
                    col += 1

                # Write sensor type header
                worksheet.merge_cells(start_row=start_row, start_column=col, end_row=start_row, end_column=col+3)
                cell = worksheet.cell(row=start_row, column=col)
                cell.value = sensor_type
                cell.alignment = openpyxl.styles.Alignment(horizontal='center', vertical='center')
                cell.font = openpyxl.styles.Font(bold=True, size=12)
                cell.fill = openpyxl.styles.PatternFill(start_color=colors['average'].lstrip('#'), end_color=colors['average'].lstrip('#'), fill_type="solid")
                cell.font = openpyxl.styles.Font(color="000000", bold=True, size=12)

                # Write section headers
                headers = ['Timestamp', 'Avg.', 'Normal', 'Absolute']
                for j, header in enumerate(headers):
                    cell = worksheet.cell(row=start_row+1, column=col+j)
                    cell.value = header
                    cell.font = openpyxl.styles.Font(bold=True)
                    cell.fill = openpyxl.styles.PatternFill(start_color=colors['normalized'].lstrip('#'), end_color=colors['normalized'].lstrip('#'), fill_type="solid")
                    cell.font = openpyxl.styles.Font(color="000000", bold=True)
                    cell.alignment = openpyxl.styles.Alignment(horizontal='center')

                # Write data in batches
                for row in range(x_range):
                    # Timestamp
                    cell = worksheet.cell(row=start_row+row+2, column=col)
                    cell.value = stats['timestamps'][row].strftime('%Y-%m-%d %H:%M') if stats['timestamps'][row] else ''
                    cell.alignment = openpyxl.styles.Alignment(horizontal='center')

                    # Average value
                    cell = worksheet.cell(row=start_row+row+2, column=col+1)
                    cell.value = stats['averages'][row]
                    cell.fill = openpyxl.styles.PatternFill(start_color=colors['average'].lstrip('#'), end_color=colors['average'].lstrip('#'), fill_type="solid")
                    cell.font = openpyxl.styles.Font(color="000000")

                    # Normalized value
                    cell = worksheet.cell(row=start_row+row+2, column=col+2)
                    cell.value = stats['normalized'][row]
                    cell.fill = openpyxl.styles.PatternFill(start_color=colors['normalized'].lstrip('#'), end_color=colors['normalized'].lstrip('#'), fill_type="solid")
                    cell.font = openpyxl.styles.Font(color="000000")

                    # Absolute value
                    cell = worksheet.cell(row=start_row+row+2, column=col+3)
                    cell.value = stats['absolute'][row]
                    cell.fill = openpyxl.styles.PatternFill(start_color=colors['absolute'].lstrip('#'), end_color=colors['absolute'].lstrip('#'), fill_type="solid")
                    cell.font = openpyxl.styles.Font(color="000000")

                # Add borders to all cells in this section
                for row in range(start_row, start_row + x_range + 2):
                    for c in range(col, col + 4):
                        cell = worksheet.cell(row=row, column=c)
                        cell.border = openpyxl.styles.Border(
                            left=openpyxl.styles.Side(style='thin'),
                            right=openpyxl.styles.Side(style='thin'),
                            top=openpyxl.styles.Side(style='thin'),
                            bottom=openpyxl.styles.Side(style='thin')
                        )

                col += 4

            # Remove the default sheet
            if 'Sheet' in workbook.sheetnames:
                del workbook['Sheet']

            # Auto-adjust column widths
            for column in worksheet.columns:
                max_length = 0
                column = [cell for cell in column]
                for cell in column:
                    try:
                        if len(str(cell.value)) > max_length:
                            max_length = len(str(cell.value))
                    except:
                        pass
                adjusted_width = (max_length + 2)
                worksheet.column_dimensions[openpyxl.utils.get_column_letter(column[0].column)].width = adjusted_width

        print(f"Data exported successfully to {filename}")
        files.download(filename)
    except Exception as e:
        print(f"Error saving file: {str(e)}")

""" Get the selected sensors """
def get_selected_sensors(checkboxes):
    sensor_types = []
    # Skip the first checkbox (All) when collecting sensor types
    for i in range(1, len(checkboxes.children)):
        if checkboxes.children[i].value:
            sensor_types.append(checkboxes.children[i].description)
    if 'All' in sensor_types:
        sensor_types = [checkboxes.children[i].description for i in range(len(checkboxes.children))]
    return sensor_types

""" Get min and max dates from all sensor history """
def get_sensor_date_range():
    min_date = None
    max_date = None

    try:
        result = FBconn.get('/Sensors/', None)
        for location in result.keys():
            for sensor_type, sensor_info in result[location].items():
                for record_id, record in sensor_info['history'].items():
                    try:
                        timestamp = record['timestamp']
                        try:
                            # Try full datetime format
                            record_date = datetime.strptime(timestamp, '%Y-%m-%d %H:%M:%S').date()
                        except ValueError:
                            try:
                                # Try date only format
                                record_date = datetime.strptime(timestamp, '%Y-%m-%d').date()
                            except ValueError:
                                try:
                                    # Try time only format (assume today's date)
                                    time_only = datetime.strptime(timestamp, '%H:%M:%S').time()
                                    record_date = datetime.now().date()
                                except ValueError:
                                    continue

                        if min_date is None or record_date < min_date:
                            min_date = record_date
                        if max_date is None or record_date > max_date:
                            max_date = record_date
                    except Exception:
                        continue
    except Exception as e:
        print(f"Error getting date range: {e}")

    # If no valid dates found, use last 30 days as default
    if min_date is None or max_date is None:
        max_date = datetime.now().date()
        min_date = max_date - timedelta(days=30)

    return min_date, max_date

""" Create the statistics tab """
def create_statistics_tab():
    output = widgets.Output()
    label_output = widgets.Output()  # Add label output widget

    # Get min and max dates from sensor history
    min_date, max_date = get_sensor_date_range()

    # Create date range pickers with min/max constraints
    start_date = widgets.DatePicker(
        description='Start Date:',
        disabled=False,
        min=min_date,
        max=max_date
    )
    end_date = widgets.DatePicker(
        description='End Date:',
        disabled=False,
        min=min_date,
        max=max_date
    )

    # Set default dates (last 30 days or within available range)
    end_date.value = min(max_date, datetime.now().date())
    start_date.value = max(min_date, end_date.value - timedelta(days=30))

    def validate_and_create_graphs(b):
        # Validate dates
        if start_date.value > end_date.value:
            with label_output:
                label_output.clear_output()
                print("Error: Start date is after end date")
            return
        if start_date.value < min_date or start_date.value > max_date:
            with label_output:
                label_output.clear_output()
                print(f"Error: Start date must be between {min_date} and {max_date}")
            return
        if end_date.value < min_date or end_date.value > max_date:
            with label_output:
                label_output.clear_output()
                print(f"Error: End date must be between {min_date} and {max_date}")
            return

        # If validation passes, create graphs
        create_button_click(output, label_output, colorMap, get_selected_sensors(checkboxes), start_date.value, end_date.value)

    # Create checkboxes for sensor selection
    checkboxes = create_checkboxes()

    # Create button
    create_button = widgets.Button(description='Make Graphs')
    create_button.on_click(validate_and_create_graphs)

    # Clear button
    clear_button = widgets.Button(description='Clear Graphs')
    def clear_graphs(b):
        output.clear_output()
        with label_output:
            label_output.clear_output()
            print("Cleared graphs")
    clear_button.on_click(clear_graphs)

    # Excel export button
    excel_button = widgets.Button(description='Export to Excel')
    def export_excel(b):
        with label_output:
            label_output.clear_output()
            print("Exporting to Excel...")
        export_to_excel(get_selected_sensors(checkboxes), start_date.value, end_date.value)
    excel_button.on_click(export_excel)

    # Layout
    date_box = widgets.HBox([start_date, end_date])
    buttons_box = widgets.HBox([create_button, clear_button, excel_button])
    tab_content = widgets.VBox([date_box, checkboxes, buttons_box, label_output, output])

    return tab_content

""" Handle the click event """
def create_button_click(output, label_output, colorMap, sensor_types, start_date, end_date):
    with label_output:
        label_output.clear_output()
        print("Loading...")
    sensor_data = get_sensor_data(start_date, end_date)
    if not sensor_types:
        with label_output:
            label_output.clear_output()
            print("No sensors selected for graphing")
        return

    with output:
        output.clear_output()
        # Separate indoor and outdoor sensors
        indoor_sensors = []
        outdoor_sensors = []
        for sensor_type in sensor_types:
            for sensor in sensor_data:
                if sensor["type"] == sensor_type:
                    if "-indoor" in sensor_type:
                        indoor_sensors.append(sensor)
                    else:
                        outdoor_sensors.append(sensor)
                    break

        num_rows = 5 if len(indoor_sensors) > 0 else 0
        num_rows += 4 if len(outdoor_sensors) > 0 else 0

        # Increase figure height for better visibility
        fig = plt.figure(figsize=(25, num_rows*4))
        grid = fig.add_gridspec(num_rows, 4, hspace=1.2, wspace=0.3)

        if not indoor_sensors and not outdoor_sensors:
            with label_output:
                label_output.clear_output()
                print("No sensor data available")
            return

        with label_output:
            label_output.clear_output()
            print("Generated graphs")

        # Plot indoor sensors first
        if indoor_sensors:
            # Add indoor section label
            ax_label = fig.add_subplot(grid[0, 0:4])
            ax_label.axis('off')
            ax_label.text(0.5, 0.5, 'Indoor Sensors',
                         horizontalalignment='center',
                         verticalalignment='center',
                         fontsize=20,
                         fontweight='bold',
                         bbox=dict(facecolor='lightgray', alpha=0.5, boxstyle='round,pad=1'))

            plot_all_graphs(fig, grid, indoor_sensors, colorMap, start_row=1)
            if len(indoor_sensors) >= 2:
                plot_all_heatmaps(fig, grid, indoor_sensors, [s['type'] for s in indoor_sensors], start_row=4)

        # Plot outdoor sensors
        if outdoor_sensors:
            start_row = 5 if len(indoor_sensors) > 0 else 0
            # Add outdoor section label
            ax_label = fig.add_subplot(grid[start_row, 0:4])
            ax_label.axis('off')
            ax_label.text(0.5, 0.5, 'Outdoor Sensors',
                         horizontalalignment='center',
                         verticalalignment='center',
                         fontsize=20,
                         fontweight='bold',
                         bbox=dict(facecolor='lightgray', alpha=0.5, boxstyle='round,pad=1'))

            plot_all_graphs(fig, grid, outdoor_sensors, colorMap, start_row=start_row + 1, start_col=0)

        plt.show()

""" Plot all graphs """
def plot_all_graphs(fig, grid, sensors, colorMap, start_row=0, start_col=0):
    plot_types = ['average', 'normalized', 'absolute']
    x_values = range(1, x_range + 1)

    for row, plot_type in enumerate(plot_types):
        for col, sensor in enumerate(sensors):
            ax = fig.add_subplot(grid[row + start_row, col + start_col])
            sensor_type = sensor['type']
            color_by_type = colorMap[sensor_type]
            color = color_by_type[plot_type]

            if plot_type == 'average':
                plot_average_graph(ax, sensor, x_values, color)
            elif plot_type == 'normalized':
                plot_normalized_graph(ax, sensor, x_values, color)
            elif plot_type == 'absolute':
                plot_absolute_graph(ax, sensor, x_values, color)

""" Plot the heatmaps """
def plot_all_heatmaps(fig, grid, sensors, sensor_types, start_row=0, start_col=0):
    if len(sensors) < 2:
        return

    inc = 0
    if 'Temperature-indoor' in sensor_types and 'Humidity-indoor' in sensor_types:
        ax_temp_humid = fig.add_subplot(grid[start_row, start_col + inc:start_col + inc + 2])
        plot_diff_heatmap(ax_temp_humid, sensors, 'Temperature-indoor', 'Humidity-indoor')
        inc += 2

    if 'Pressure-indoor' in sensor_types and 'Humidity-indoor' in sensor_types:
        ax_press_humid = fig.add_subplot(grid[start_row, start_col + inc:start_col + inc + 2])
        plot_diff_heatmap(ax_press_humid, sensors, 'Pressure-indoor', 'Humidity-indoor')

""" Calculate the average of the values with timestamps """
def average_by_x_values(values, timestamps):
    averages = []
    avg_timestamps = []

    for i in range(x_range):
        start_idx = i * step
        end_idx = start_idx + step
        segment = values[start_idx:end_idx]
        segment_timestamps = timestamps[start_idx:end_idx]
        if segment:
            averages.append(sum(segment) / len(segment))
            # Use the middle timestamp of the segment
            avg_timestamps.append(segment_timestamps[len(segment_timestamps)//2])
        else:
            averages.append(0)
            avg_timestamps.append(None)
    return averages, avg_timestamps

""" Calculate the absolute changes of the values """
def calculate_absolute_changes(values, timestamps):
    averages, avg_timestamps = average_by_x_values(values, timestamps)
    # Get the first measurement value
    initial_value = values[0] if values else 0
    changes = []
    for avg in averages:
        changes.append(avg - initial_value)
    return changes, avg_timestamps

""" Calculate the normalized changes of the values by segments """
def calculate_normalized_changes(values, timestamps):
    averages, avg_timestamps = average_by_x_values(values, timestamps)
    # Calculate overall average instead of using initial value
    overall_avg = sum(averages) / len(averages) if averages else 0
    normalized = []
    for avg in averages:
        if overall_avg != 0:
            normalized.append(((avg - overall_avg) / overall_avg) * 100)
        else:
            normalized.append(0)
    return normalized, avg_timestamps

""" Plot the graph """
def plot_graph(ax, y_values, x_values, timestamps, color, title, xlabel, ylabel, plot_type, sensor_type):
    if plot_type == 'line':
        ax.plot(x_values, y_values, marker='o', color=color, label=sensor_type)
    elif plot_type == 'bar':
        ax.bar(x_values, y_values, color=color, alpha=0.7, label=sensor_type)

    segment_avg = sum(y_values) / len(y_values)
    ax.axhline(y=segment_avg, color='black', linestyle='-', label=f'Avg: {segment_avg:.2f}')

    # Show only 5 evenly spaced x-axis labels
    num_points = len(x_values)
    if num_points > 1:
        label_indices = [int(round(i * (num_points - 1) / 4)) for i in range(5)]
    else:
        label_indices = [0]
    tick_positions = [x_values[i] for i in label_indices]
    tick_labels = [timestamps[i].strftime('%d/%m-%H:%M:%S') if timestamps[i] else '' for i in label_indices]
    ax.set_xticks(tick_positions)
    ax.set_xticklabels(tick_labels, rotation=45, ha='right')

    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.grid(True)
    ax.legend()
    plt.tight_layout()

""" Plot the average graph """
def plot_average_graph(ax, sensor, x_values, color):
    averages, timestamps = average_by_x_values(sensor['values'], sensor['timestamps'])
    title = f"{sensor['type']} - Segment Averages"
    x_label = "Timestamp"
    y_label = "Average Value"
    plot_type = "line"
    plot_graph(ax, averages, x_values, timestamps, color, title, x_label, y_label, plot_type, sensor['type'])

""" Plot the absolute graph """
def plot_absolute_graph(ax, sensor, x_values, color):
    changes, timestamps = calculate_absolute_changes(sensor['values'], sensor['timestamps'])
    title = f"{sensor['type']} - Differences"
    x_label = "Timestamp"
    y_label = "Difference from Initial"
    plot_type = "bar"
    plot_graph(ax, changes, x_values, timestamps, color, title, x_label, y_label, plot_type, sensor['type'])

""" Plot the normalized graph """
def plot_normalized_graph(ax, sensor, x_values, color):
    changes, timestamps = calculate_normalized_changes(sensor['values'], sensor['timestamps'])
    title = f"{sensor['type']} - Percentage Changes"
    x_label = "Timestamp"
    y_label = "Change from Average (%)"
    plot_type = "line"
    plot_graph(ax, changes, x_values, timestamps, color, title, x_label, y_label, plot_type, sensor['type'])

""" Plot the difference heatmap between two sensors """
def plot_diff_heatmap(ax, sensors, sensor1, sensor2):
    sensor1 = get_sensor(sensors, sensor1)
    sensor2 = get_sensor(sensors, sensor2)

    sensor1_normalized, timestamps1 = calculate_normalized_changes(sensor1['values'], sensor1['timestamps'])
    sensor2_normalized, _ = calculate_normalized_changes(sensor2['values'], sensor2['timestamps'])

    sensors_diff = [abs(sensor1_normalized[i] - sensor2_normalized[i]) for i in range(x_range)]

    # Normalize the difference
    max_diff = max(sensors_diff)
    if max_diff > 0:
        sensors_diff = [diff/max_diff for diff in sensors_diff]

    # Create heatmap using matplotlib
    im = ax.imshow([sensors_diff],
                  cmap='YlOrRd',
                  aspect='auto',
                  extent=[0.5, x_range + 0.5, 0.5, 1.5])

    # Add colorbar
    plt.colorbar(im, ax=ax)

    # Show only 5 evenly spaced x-axis labels
    num_points = x_range
    if num_points > 1:
        label_indices = [int(round(i * (num_points - 1) / 4)) for i in range(5)]
    else:
        label_indices = [0]
    tick_positions = [i+1 for i in label_indices]
    tick_labels = [timestamps1[i].strftime('%d/%m-%H:%M:%S') if timestamps1[i] else '' for i in label_indices]
    ax.set_xticks(tick_positions)
    ax.set_xticklabels(tick_labels, rotation=45, ha='right')
    ax.set_yticks([])
    ax.set_title(f"{sensor1['type']} - {sensor2['type']} Normalized Difference")
    ax.set_xlabel("Timestamp")
    plt.tight_layout()

""" Plot a row of graphs by type of sensor and plot type """
def plot_graphs_by_type(ax, fig, gs, sensors, colorMap, show):
    x_values = range(1, x_range + 1)

    for i, sensor in enumerate(sensors):
        ax = fig.add_subplot(gs[0, i])
        sensor_type = sensor['type']
        color = colorMap[sensor_type]['average']

        if show == 'average':
            plot_average_graph(ax, sensor, x_values, color)
        elif show == 'normalized':
            plot_normalized_graph(ax, sensor, x_values, color)
        elif show == 'absolute':
            plot_absolute_graph(ax, sensor, x_values, color)
    return ax

""" Get the sensor by type """
def get_sensor(sensors, sensor_type):
    for sensor in sensors:
        if sensor['type'] == sensor_type:
            return sensor
    return None

tab3_content = create_statistics_tab()



tab11_content = widgets.Output()

with tab11_content:
    # UI display
    run_btn = widgets.Button(description="Run Big-Data Analysis",
                             button_style='success',
                             layout=widgets.Layout(width='220px', height='40px'))
    output_bd = widgets.Output()

    # Button that generates the bar diagram
    def run_bigdata_click(_):
        with output_bd:
            # Clean previous output
            clear_output()
            print("‚è≥ Exporting Firebase history ...")
            # Pull data to csv
            dump_history_to_csv()
            print("‚è≥ Running Spark job ‚Äì please wait ...")
            try:
                avg_pd = run_spark_pipeline("sensor_history.csv")
                # Display the chart bar
                plot_bigdata_charts(avg_pd)
                print("‚úÖ Done.")
            # Catch the exceptions
            except Exception as e:
                print("‚ùå Error:", e)

    run_btn.on_click(run_bigdata_click)

    #render UI
    display(widgets.VBox([
        widgets.HTML("<h2>üìä Big Data Insights</h2>"),
        run_btn,
        output_bd
    ], layout=widgets.Layout(align_items='flex-start')))

"""# **Tab 6 - Task Manager**
First Cell: Logic,
Second Cell: UI
"""

# Fetches a list of worker names for dropdown menus
def get_workers_for_dropdown():
    try:
      # Retrieve all workers from Firebase
      workers = FBconn.get('/workers/', None)
      # Extract and return the list of worker names
      worker_names = [worker['name'] for worker in workers]
      return worker_names

    except:
      # Return empty list if any error occurs
      return []

# Generates the next available task ID in the format 'T001', 'T002', ...
def get_next_task_id():
    # Get all current tasks from Firebase
    tasks = FBconn.get('/TaskManager/', None)
    if not tasks:
        # Return initial ID if no tasks exist yet
        return "T001"
    try:
      # Extract numeric parts of task IDs
      used_ids = sorted([int(k[1:]) for k in tasks.keys() if k.startswith("T") and k[1:].isdigit()])
      # Find the smallest unused ID number starting from 1
      for i in range(1, used_ids[-1] + 2):
            if i not in used_ids:
              # Format with leading zeros
              return f"T{i:03d}"
    except:
        # In case of error, fallback to initial ID
        pass
    return "T001"

# Get list of workers from Firebase
def get_workers():
    try:
        workers = FBconn.get('/workers/', None)
        # Return workers if found, else empty list
        return workers if workers else []
    except:
        return []

# Output widget container for the content of Tab 6
tab6_content = Output()

with tab6_content:
    # Fetch the list of all workers from Firebase
    workers = get_workers()
    # Extract worker names for dropdown options
    worker_names = [worker['name'] for worker in workers]

    # Fetch all task data from Firebase
    task_data = FBconn.get('/TaskManager/', None)

    # Output widgets for various UI parts
    task_action_output = Output()  # For action feedback
    task_output = Output(layout=Layout(height='300px', overflow_y='auto', border='1px solid #ccc'))  # Scrollable task table display
    edit_log_output = Output()     # Logs for task edit actions
    edit_form_output = Output()    # Container for the task edit form fields
    task_log_output = Output()     # Logs for task creation actions

    # Dropdown to select a task ID for editing/deleting
    task_ids = list(task_data.keys()) if task_data else []
    task_select_dropdown = Dropdown(
        options=["Choose A Task ID"] + task_ids,
        value="Choose A Task ID",
        description='Edit Task:',
        layout=Layout(width='50%')
    )

    # Filter dropdowns to filter tasks by Status, Priority, and Assignee
    filter_status = Dropdown(options=["All", "To Do", "In Progress", "Done"], value="All", description="Status:")
    filter_priority = Dropdown(options=["All", "Low", "Medium", "High"], value="All", description="Priority:")
    filter_assignee = Dropdown(options=["All"] + worker_names, value="All", description="Assignee:")

    # Fields for editing selected task details
    edit_assignee = Dropdown(options=worker_names, description="Assigned to:", layout=Layout(width='50%'))
    edit_title = Textarea(description="Title:", layout=Layout(width='100%', height='30px'))
    edit_status = Dropdown(options=["To Do", "In Progress", "Done"], description="Status:")
    edit_priority = Dropdown(options=["Low", "Medium", "High"], description="Priority:")
    edit_score_input = BoundedIntText(value=0, min=0, max=100, step=1, description="Score:", layout=Layout(width='50%'))
    edit_details = Textarea(description="Details:", layout=Layout(width='100%', height='60px'))

    # ---------- Task Table Display and Filtering ----------

    def refresh_task_table(*args):
        # Reload tasks from Firebase
        new_task_data = FBconn.get('/TaskManager/', None) or {}

        # Filter tasks based on selected filters
        tasks = []
        for tid, task in new_task_data.items():
            if filter_status.value != "All" and task["Status"] != filter_status.value:
                continue
            if filter_priority.value != "All" and task["Priority"] != filter_priority.value:
                continue
            if filter_assignee.value != "All" and task["Assigned_To"] != filter_assignee.value:
                continue
            task_copy = task.copy()
            task_copy["Task ID"] = tid
            tasks.append(task_copy)

        with task_output:
            clear_output()
            if not tasks:
                # Show message if no tasks match filters
                display(HTML("<p style='text-align:center;color:gray;'>No tasks found.</p>"))
                return

            rows = []
            # Header labels for the task table
            headers = ["Task ID", "Assigned_To", "Title", "Status", "Priority", "Score", "Actions"]
            header_widgets = [Label(h, layout=Layout(width='150px', font_weight='bold')) for h in headers]
            rows.append(HBox(header_widgets))

            # Confirm button is clicked for a Done task
            def on_confirm_click(b):
                task_id = b.task_id
                task = new_task_data.get(task_id)
                if not task:
                    return

                assigned_worker_name = task["Assigned_To"]
                task_score = task.get("Score", 0)

                # Fetch all workers, update the assigned worker's score by adding task score
                workers = FBconn.get('/workers/', None) or {}
                updated = False
                for worker_key, worker_data in enumerate(workers):
                    if worker_data.get("name") == assigned_worker_name:
                        current_score = worker_data.get("score", 0)
                        worker_data["score"] = current_score + task_score
                        FBconn.put('/workers/', str(worker_key), worker_data)  # Update worker data in Firebase
                        updated = True
                        break

                # Delete the task from TaskManager after updating the score
                FBconn.delete('/TaskManager/', task_id)

                # Show confirmation message of the action
                with task_action_output:
                    clear_output()
                    if updated:
                        print(f"‚úÖ Added {task_score} points to {assigned_worker_name} and deleted task {task_id}.")
                    else:
                        print(f"‚ö†Ô∏è Worker {assigned_worker_name} not found. Task deleted.")

                # Refresh the task table display after action
                refresh_task_table()

            # Build the rows for each task to display in the table
            for t in tasks:
                row_widgets = [
                    Label(t["Task ID"], layout=Layout(width='150px')),
                    Label(t["Assigned_To"], layout=Layout(width='150px')),
                    Label(t["Title"], layout=Layout(width='150px')),
                    Label(t["Status"], layout=Layout(width='100px')),
                    Label(t["Priority"], layout=Layout(width='100px')),
                    Label(str(t.get("Score", 0)), layout=Layout(width='50px')),
                ]
                # Add Confirm button only if task status is Done
                if t["Status"] == "Done":
                    confirm_button = Button(description="Confirm", button_style='success', layout=Layout(width='80px'))
                    confirm_button.task_id = t["Task ID"]
                    confirm_button.on_click(on_confirm_click)
                    row_widgets.append(confirm_button)
                else:
                    # Empty label as placeholder if no button
                    row_widgets.append(Label("", layout=Layout(width='80px')))

                rows.append(HBox(row_widgets))

            display(VBox(rows))

        # Update the dropdown with current task IDs and reset selection
        task_ids_updated = list(new_task_data.keys())
        task_select_dropdown.options = ["Choose A Task ID"] + task_ids_updated
        task_select_dropdown.value = "Choose A Task ID"

        # Clear the edit form output on refresh
        with edit_form_output:
            clear_output()

    # Attach observers to filters to refresh the table when filter values change
    filter_status.observe(refresh_task_table, names='value')
    filter_priority.observe(refresh_task_table, names='value')
    filter_assignee.observe(refresh_task_table, names='value')

    # ---------- Edit Task Form Logic ----------

    def on_task_select(change):
        task_id = change['new']
        with edit_form_output:
            clear_output()
            if task_id and task_id != "Choose A Task ID":
                task = FBconn.get('/TaskManager/', None).get(task_id)
                if task:
                    # Populate edit fields with task's current values
                    edit_assignee.value = task["Assigned_To"]
                    edit_title.value = task["Title"]
                    edit_status.value = task["Status"]
                    edit_priority.value = task["Priority"]
                    edit_score_input.value = task.get("Score", 0)
                    edit_details.value = task["Description"]

                    # Display the edit form UI elements
                    display(VBox([
                        edit_assignee,
                        edit_title,
                        edit_status,
                        edit_priority,
                        edit_score_input,
                        edit_details,
                        HBox([edit_button, delete_button]),
                        edit_log_output
                    ], layout=Layout(max_width='100%')))

    task_select_dropdown.observe(on_task_select, names='value')

    def update_task(_):
        # Save updated task info to Firebase when edit form is submitted
        task_id = task_select_dropdown.value
        updated_task = {
            "Assigned_To": edit_assignee.value,
            "Title": edit_title.value,
            "Status": edit_status.value,
            "Priority": edit_priority.value,
            "Score": edit_score_input.value,
            "Description": edit_details.value
        }
        FBconn.put('/TaskManager/', task_id, updated_task)
        with edit_log_output:
            clear_output()
            print(f"‚úÖ Task {task_id} updated.")
        refresh_task_table()

    def delete_task(_):
        # Show confirmation buttons before deleting a task
        task_id = task_select_dropdown.value
        confirm = ToggleButtons(
            options=['Cancel', 'Yes, Delete'],
            value=None,
            description=f"Are you sure you want to delete {task_id}?",
            style={'description_width': 'initial'}
        )
        confirm_output = Output()

        def handle_confirm(change):
            task_log_output.clear_output()
            if change['new'] == 'Yes, Delete':
                # Delete task from Firebase
                FBconn.delete('/TaskManager/', task_id)
                with edit_log_output:
                    clear_output()
                refresh_task_table()
                refresh_new_task()
            else:
                # Cancel delete action
                with edit_log_output:
                    clear_output()

        confirm.observe(handle_confirm, names='value')
        with edit_log_output:
            clear_output()
            display(VBox([confirm, confirm_output]))

    # Buttons for submitting edits or deleting a task
    edit_button = Button(description="‚úèÔ∏è Update Task", button_style='info')
    edit_button.on_click(update_task)

    delete_button = Button(description="üóëÔ∏è Delete Task", button_style='danger')
    delete_button.on_click(delete_task)

    # ---------- New Task Creation Form ----------

    # Inputs for new task fields
    task_id_input = Text(value=get_next_task_id(), disabled=True, layout=Layout(width='150px', height='33px'))
    assigned_dropdown = Dropdown(options=worker_names, description='Assign to:', layout=Layout(width='50%'))
    title_text_input = Text(description='Title:', placeholder='Enter task title...', layout=Layout(width='50%'))
    status_dropdown = Dropdown(options=["To Do", "In Progress", "Done"], description='Status:', layout=Layout(width='50%'))
    priority_dropdown = Dropdown(options=["Low", "Medium", "High"], description='Priority:', layout=Layout(width='50%'))
    score_input = BoundedIntText(value=0, min=0, max=100, step=1, description='Score:', layout=Layout(width='150px', height='33px'))
    task_details_textarea = Textarea(placeholder='Enter task details...', description='Details:', layout=Layout(width='100%', height='60px'))
    start_date_input = DatePicker(description="Start Date", value=datetime.today().date(), layout=Layout(width='50%'))
    due_date_input = DatePicker(description="Due Date", value=datetime.today().date(), layout=Layout(width='50%'))
    save_task_button = Button(description="Add Task", button_style='success', layout=Layout(height='60px'))

    def refresh_new_task():
        # Reset new task form to defaults and get new task ID
        task_id_input.value = get_next_task_id()
        assigned_dropdown.value = worker_names[0] if worker_names else None
        title_text_input.value = ""
        status_dropdown.value = "To Do"
        priority_dropdown.value = "Low"
        score_input.value = 0
        task_details_textarea.value = ""
        start_date_input.value = datetime.today().date()
        due_date_input.value = datetime.today().date()

    def save_task(_):
        # Save new task to Firebase when Add Task button clicked
        task_id = task_id_input.value.strip()
        if not title_text_input.value.strip():
            # Require a task title
            with task_log_output:
                clear_output()
                print("‚ùå Add a Task Title")
        else:
            new_task = {
                "ID": task_id,
                "Assigned_To": assigned_dropdown.value,
                "Title": title_text_input.value.strip(),
                "Status": status_dropdown.value,
                "Priority": priority_dropdown.value,
                "Score": score_input.value,
                "Description": task_details_textarea.value.strip(),
                "Start_Date": start_date_input.value.strftime('%Y-%m-%d'),
                "Due_Date": due_date_input.value.strftime('%Y-%m-%d')
            }
            # Save new task data to Firebase
            FBconn.put('/TaskManager/', task_id, new_task)
            # Refresh the task table and reset the new task form
            refresh_task_table()
            refresh_new_task()
            with task_log_output:
                clear_output()
                print(f"‚úÖ Task {task_id} created.")

    save_task_button.on_click(save_task)

    # Initial population of the task table display
    refresh_task_table()

    # ---------- Final Layout Display ----------

    display(
        VBox([
            # Upper section with task table and edit/delete form side by side
            HBox([
                VBox([
                    Label("üóÇÔ∏è Tasks Manager:"),
                    HBox([filter_status, filter_priority, filter_assignee]),
                    task_output,
                    task_action_output,
                ], layout=Layout(width='60%', padding='10px')),

                VBox([
                    Label("‚úèÔ∏è Select a Task to Edit or üóëÔ∏è Delete"),
                    task_select_dropdown,
                    edit_form_output
                ], layout=Layout(width='40%', padding='10px'))
            ], layout=Layout(width='100%')),

            # Lower section with new task creation form
            HBox([
                VBox([
                    Label("‚ûï Assign New Task"),
                    HBox([Label("Task ID:", layout=Layout(min_width='90px')), task_id_input, score_input], layout=Layout(align_items='center')),
                    HBox([assigned_dropdown, title_text_input]),
                    HBox([status_dropdown, priority_dropdown]),
                    HBox([start_date_input, due_date_input]),
                    HBox([task_details_textarea, save_task_button]),
                    task_log_output
                ], layout=Layout(width='50%', padding='10px')),
            ])
        ])
    )

"""# **Tab 8 - Login Page**"""

# Tab 8 : Login
"""
    Function to show the tabs based on the user type

    @param logged_user - Object : The user that is logged in
"""
def show_tabs(logged_user):
    global tabs

    # universal tabs
    show_tabs = ['Login','Search']

    # show worker tabs
    if logged_user is not None and logged_user['type'] == 'worker':
        show_tabs = ['Dashboard', 'Search', "My Tasks", 'Statistics', 'My Sensors', 'Store', 'Login']

    # show admin tabs
    if logged_user is not None and logged_user['type'] == 'admin':
        show_tabs = ['Dashboard', 'Search', 'Tasks Manager', 'Statistics', 'Overall Sensors','Store', 'Login']

    # for each tab in show_tabs, create the tab with a title
    tabs = widgets.Tab(children=[tab_title_map[title] for title in show_tabs])
    for i, title in enumerate(show_tabs):
        tabs.set_title(i, title)

    # clear the output and display the tabs
    clear_output(wait=True)
    display(tabs)

"""
    Function to validate the login credentials

    @param usernameOrEmail - String : The username or email to validate
    @param password - String : The password to validate
    @return - Object : The error message or the user that is logged in
"""
def validate_login(usernameOrEmail, password):
    # logged in user check
    if logged_user is not None:
        name = logged_user['user']['name']
        return f'{name} is already logged in'

    # no username/email check
    if not usernameOrEmail:
        return 'Must enter username/email'

    # no password check
    if not password:
        return 'Must enter password'

    # email check (worker)
    if '@' in usernameOrEmail and '.' in usernameOrEmail:
        workers = FBconn.get('/workers', None)
        for worker in workers:
            # equal email check
            if worker['email'] == usernameOrEmail:
                # equal password check
                if worker['password'] == password:
                    return {'user': worker, 'type': 'worker'}

                return 'Invalid password for email'
    else:
        # username check (admin)
        admins = FBconn.get('/admins', None)
        for admin in admins:
            # equal username check
            if admin['username'] == usernameOrEmail:
                # equal password check
                if admin['password'] == password:
                    return {'user': admin, 'type': 'admin'}
                return 'Invalid password for username'

    # invalid username/email
    return 'Invalid username/email'

"""
    Function to handle the login button click

    @param _ - Object : The button that was clicked
"""
def login_button_clicked(_):
    # get the username/email and password from the input fields
    usernameOrEmail = user_input_text.value
    password = password_input_text.value

    # clear the error label
    error_label.value = ''

    # validate the login credentials - returns error message or user object
    global logged_user
    result = validate_login(usernameOrEmail, password)

    # if the result is a string, set the error label to the result
    if type(result) == str:
        error_label.value = result
    else:
        # if result is a user object, handle the login
        # clear the input fields
        user_input_text.value = ''
        password_input_text.value = ''

        # set the logged user
        logged_user = result

        # change the login title
        greeting.value = change_login_title()

        # load the store tab
        load_store_tab(logged_user['user'])

        # refresh the task table
        refresh_task_table()

        # refresh the worker task table
        worker_refresh_task_table()

        # show the tabs
        show_tabs(logged_user)

"""
    Function to handle the logout button click

    @param _ - Object : The button that was clicked
"""
def logout_button_clicked(_):
    # clear the error label
    error_label.value = ''

    # non-logged in user check
    global logged_user
    if logged_user is None:
        error_label.value = 'No user logged in'
    else:
        # clear the logged user
        logged_user = None

        # change the login title
        greeting.value = change_login_title()

        # show the tabs
        show_tabs(logged_user)

"""
    Function to change the login title

    @return - String : The login title
"""
def change_login_title():
    global logged_user
    if logged_user is None:
        return 'Hello new user, please Log in'
    else:
        name = logged_user['user']['name']
        return f'Hello {name}, Logging out?'

tab8_content = widgets.Output()
with tab8_content:
    # Style user label
    user_label = widgets.HTML(
        "<b>Username/Email:</b>",
        layout=widgets.Layout(width='150px', text_align='right')
    )
    user_label.style = {'font_size': '30px'}

    # Style password label
    pass_label = widgets.HTML(
        "<b>Password:</b>",
        layout=widgets.Layout(width='150px', text_align='right')
    )
    pass_label.style = {'font_size': '30px'}

    # Style user input text
    user_input_text = widgets.Text(
        placeholder='something@gmail.com / someUsername',
        layout=widgets.Layout(width='350px')
    )
    user_input_text.style = {'font_size': '30px'}

    # Style password input text
    password_input_text = widgets.Text(
        placeholder='secretPass',
        layout=widgets.Layout(width='350px')
    )
    password_input_text.style = {'font_size': '30px'}

    # Style error label
    error_label = widgets.Label(
        value='',
        layout=widgets.Layout(margin='10px 0 0 0')
    )
    error_label.style = {'font_size': '30px'}

    # Style login button
    login_button = widgets.Button(
        description="Login",
        button_style='success',
        layout=widgets.Layout(width='180px', height='60px', margin='10px 0 0 0')
    )
    login_button.style = {'font_size': '30px'}
    login_button.on_click(login_button_clicked)

    # Style logout button
    logout_button = widgets.Button(
        description="Logout",
        button_style='danger',
        layout=widgets.Layout(width='180px', height='60px', margin='10px 0 0 10px')
    )
    logout_button.style = {'font_size': '30px'}
    logout_button.on_click(logout_button_clicked)

    # Style greeting label
    greeting = widgets.Label(value=change_login_title(), layout=widgets.Layout(text_align='center', min_height='60px', width='100%'))
    greeting.style = {'font_size': '50px'}

    # Style overall form items
    form_items = [
        greeting,
        widgets.HBox([user_label, user_input_text], layout=widgets.Layout(align_items='center', margin='10px 0')),
        widgets.HBox([pass_label, password_input_text], layout=widgets.Layout(align_items='center', margin='10px 0')),
        error_label,
        widgets.HBox([login_button, logout_button], layout=widgets.Layout(margin='20px 0 0 0'))
    ]

    # Style overall login tab
    login_box = widgets.VBox(
        form_items,
        layout=widgets.Layout(
            border='2px solid #4CAF50',
            box_shadow='0 4px 8px 0 rgba(0,0,0,0.2)',
            padding='40px',
            margin='40px auto',
            width='600px',
            align_items='center',
            background_color='#222',
            font_size='20px'
        )
    )
    display(login_box)

"""# **Tab 7 - Store Page**
First Cell: Logic,
Second Cell: UI
"""

# Mapping of store item names to emoji icons
ICON_MAP = {
    "Coffee Voucher": "‚òï",
    "Office Plant": "üåø",
    "Desk Organizer": "üìÇ",
    "Custom Mug": "üçµ",
    "Wireless Mouse": "üñ±Ô∏è",
    "Keyboard Wrist Rest": "‚å®Ô∏è",
    "Notebook Set": "üìì",
    "Desk Lamp": "üí°",
    "Ergonomic Chair Cushion": "ü™ë",
    "Bluetooth Speaker": "üîä"
}

# Fetches and returns store items sorted by key
def get_sorted_store_items():
    store_items = FBconn.get('/Store', None)
    if not store_items:
        return []
    return [store_items[key] for key in sorted(store_items.keys())]

# Builds HTML string for the store items table
# It uses CSS to style the table and highlights which items are unaffordable for the current user
def build_store_table_html(items, user_score):
    table_html = """
    <style>
        table.store-table {border-collapse: collapse; width: 100%;}
        table.store-table th, table.store-table td {border: 1px solid #ddd; padding: 8px; text-align: left;}
        table.store-table th {background-color: #222; color: #eee;}
        table.store-table tr:hover {background-color: #999;}
        .unaffordable {opacity: 0.5;}
    </style>
    <table class="store-table">
        <thead>
            <tr><th>Item</th><th>Description</th><th>Cost (pts)</th></tr>
        </thead>
        <tbody>
    """

    # Add each item to the table with appropriate styling
    for item in items:
        icon = ICON_MAP.get(item['name'], "üö´") # Default icon if item name isnt in ICON_MAP
        opacity_class = "" if user_score >= item['cost'] else "unaffordable"
        table_html += f"""
            <tr class="{opacity_class}">
                <td>{icon} {item['name']}</td>
                <td>{item['description']}</td>
                <td>{item['cost']}</td>
            </tr>
        """
    table_html += "</tbody></table>"
    return table_html

# Builds HTML string for the leaderboard showing top workers by score
def build_leaderboard_html(workers):
    trophies = {0: "ü•á", 1: "ü•à", 2: "ü•â"}  # Trophy icons for top 3 workers
    workers.sort(key=lambda w: w['score'], reverse=True)  # Sort by descending score

    html = """
    <style>
        table.leaderboard-table {
            border-collapse: collapse;
            width: 100%;
        }
        table.leaderboard-table th, table.leaderboard-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        table.leaderboard-table th {
            background-color: #222;
            color: #eee;
        }
        table.leaderboard-table tr:hover {
            background-color: #999;
        }
    </style>
    <table class="leaderboard-table">
        <thead>
            <tr><th>Rank</th><th>Name</th><th>Email</th><th>Score</th></tr>
        </thead>
        <tbody>
    """

    # Add each worker to the table with their rank
    for i, worker in enumerate(workers):
        rank = trophies.get(i, str(i + 1))  # Trophy if in top 3, otherwise numeric rank
        html += f"<tr><td>{rank}</td><td>{worker['name']}</td><td>{worker['email']}</td><td>{worker['score']}</td></tr>"
    html += "</tbody></table>"
    return html

# Output widget for the store tab
tab7_content = widgets.Output()

# HTML widget that will hold the leaderboard table
leaderboard_html_widget = widgets.HTML()

# Refreshes the leaderboard HTML with the latest workers data
def refresh_leaderboard():
    workers = get_workers()
    leaderboard_html_widget.value = build_leaderboard_html(workers)

# Loads the store tab interface for the given user
def load_store_tab(user):
    with tab7_content:
        clear_output()

        store_items = get_sorted_store_items()  # Get store items from Firebase
        if not store_items:
            print("Store is empty.")
            return

        # UI widgets
        item_dropdown = widgets.Dropdown(description='Item:', layout=widgets.Layout(width='250px'))
        item_cost = widgets.IntText(description='Cost:', disabled=True, layout=widgets.Layout(width='150px'))
        user_points = widgets.IntText(value=user.get('score', 0), description='Points:', disabled=True, layout=widgets.Layout(width='150px'))
        user_label = widgets.Label(f"Logged in as: {user['name']}")
        user_box = widgets.HBox([user_label, user_points], layout=widgets.Layout(margin='10px 0'))

        store_table = widgets.HTML()  # Store items table HTML
        confirmation_box = widgets.Output() # For purchase confirmation prompts
        output_area = widgets.Output()  # For success or cancel messages

        # Refreshes the store UI based on user's score and store data
        def refresh_store_ui():
            points = user.get('score', 0)
            affordable = [i for i in store_items if points >= i['cost']]  # Filter items the user can afford
            store_table.value = build_store_table_html(store_items, points)

            if affordable:
                # Populate dropdown with affordable items
                item_dropdown.options = [(i['name'], i['name']) for i in affordable]
                if item_dropdown.value not in [i['name'] for i in affordable]:
                    item_dropdown.value = affordable[0]['name']
                selected = next(i for i in store_items if i['name'] == item_dropdown.value)
                item_cost.value = selected['cost']
            else:
                # User can't afford anything
                item_dropdown.options = [("Not Enough Points", None)]
                item_dropdown.value = None
                item_cost.value = 0

            user_points.value = points
            refresh_leaderboard()

        # Handles dropdown value change to show correct item cost
        def on_item_change(change):
            if change['name'] == 'value' and change['new']:
                selected = next((i for i in store_items if i['name'] == change['new']), None)
                item_cost.value = selected['cost'] if selected else 0

        item_dropdown.observe(on_item_change)

        # Purchase button to initiate purchase process
        purchase_button = widgets.Button(description="Purchase", button_style='info', layout=widgets.Layout(width='100px', height='40px'))

        # Prompts the user to confirm their purchase
        def confirm_purchase(b):
            with confirmation_box:
                clear_output()
                item_name = item_dropdown.value
                if not item_name:
                    print("No item selected.")
                    return

                item = next((i for i in store_items if i['name'] == item_name), None)
                if not item or user['score'] < item['cost']:
                    print("Invalid or unaffordable item.")
                    return

                # Confirmation display
                print(f"Confirm Purchase:\nWorker: {user['name']}\nItem: {item['name']}\nCost: {item['cost']}\nRemaining: {user['score'] - item['cost']}")
                yes_button = widgets.Button(description="Confirm", button_style='success')
                no_button = widgets.Button(description="Cancel", button_style='danger')
                display(widgets.HBox([yes_button, no_button]))

                # Executes the purchase and updates Firebase
                def do_purchase(btn):
                    with output_area:
                        clear_output()
                        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        user['score'] -= item['cost']
                        workers = get_workers()

                        # Find and update the worker's score and purchase history
                        idx = next((i for i, w in enumerate(workers) if w['name'] == user['name']), None)
                        if idx is not None:
                            w = workers[idx]
                            w['score'] = user['score']
                            purchases = w.setdefault('Store_Purchases', {})
                            purchases.setdefault(item['name'], {
                                "cost": item['cost'],
                                "description": item['description'],
                                "purchase_dates": {}
                            })["purchase_dates"][timestamp] = True
                            FBconn.put('/', 'workers', workers)
                            print(f"Purchased '{item['name']}' successfully!")

                        refresh_store_ui()  # Update UI after purchase
                        with confirmation_box:
                            clear_output()

                # Cancels the purchase process
                def cancel_purchase(btn):
                    with confirmation_box:
                        clear_output()
                        print("Purchase cancelled.")

                # Confirm/Cancel actions
                yes_button.on_click(do_purchase)
                no_button.on_click(cancel_purchase)

        purchase_button.on_click(confirm_purchase)

        # Right panel showing the leaderboard
        leaderboard_title = widgets.HTML("<h3>Employees Leaderboard üèÜ</h3>")
        refresh_leaderboard()
        leaderboard_panel = widgets.VBox([leaderboard_title, leaderboard_html_widget], layout=widgets.Layout(width='48%'))

        # Left panel showing store and purchase controls
        left_panel = widgets.VBox([
            widgets.HTML("<h3>Store üõçÔ∏è</h3>"),
            store_table,
            user_box,
            widgets.HBox([widgets.VBox([item_dropdown, item_cost]), purchase_button]),
            confirmation_box,
            output_area
        ], layout=widgets.Layout(width='48%'))

        refresh_store_ui()  # Initialize UI with data

        # Render the store and leaderboard side by side
        display(widgets.VBox([
            widgets.HBox([left_panel, leaderboard_panel], layout=widgets.Layout(justify_content='space-between', gap='4%'))
        ]))

"""# **Tab 9 - My Tasks Page**"""

# Tab 9 : My Tasks
"""
    Function to refresh the task table
"""
def worker_refresh_task_table(*_):
    # get the worker tasks
    worker_tasks = get_worker_tasks()

    # filter by status and priority
    df = pd.DataFrame(worker_tasks)
    if not df.empty:
        # filter by status
        if worker_filter_status.value != "All":
            df = df[df["Status"] == worker_filter_status.value]

        # filter by priority
        if worker_filter_priority.value != "All":
            df = df[df["Priority"] == worker_filter_priority.value]

    with worker_task_output:
        # clear the output
        clear_output()

        # if no tasks are found, display a message
        if df.empty:
            display(HTML("<p style='text-align:center;color:gray;'>No tasks found.</p>"))
            return

        # define column widths
        col_widths = {
            'Task ID': '80px',
            'Title': '300px',
            'Status': '90px',
            'Priority': '90px',
            'Score': '70px',
            'Start_Date': '110px',
            'Due_Date': '110px',
            'Description': '500px',
            'Actions': '180px',
        }

        # create table header
        headers = ["Task ID", "Title", "Status", "Priority", "Score", "Start_Date", "Due_Date", "Description", "Actions"]
        header_row = [Label(h, layout=Layout(width=col_widths[h], font_weight='bold',
            border='1px solid #e0e0e0', padding='8px', background_color='#f5f5f5', text_align='center', height='50px'))
            for h in headers]
        rows = [HBox(header_row)]

        # add action buttons for each row
        for _, row in df.iterrows():
            task_id = row['Task ID']

            # create dropdown for status
            dropdown = Dropdown(
                options=["To Do", "In Progress", "Done"],
                value=row['Status'],
                layout=Layout(width='110px')
            )

            # create edit button
            edit_button = Button(
                description="‚úèÔ∏è Edit",
                button_style='info',
                layout=Layout(width='70px')
            )
            edit_button.on_click(lambda b, tid=task_id, dd=dropdown: update_task_status(tid, dd.value))

            # create overall action box
            action_box = widgets.HBox([dropdown, edit_button], layout=Layout(align_items='center', width=col_widths['Actions'], height='50px'))

            # create data row
            data_cells = [
                Label(str(row.get(col, "")), layout=Layout(width=col_widths[col], text_align='center', height='50px',
                    border='1px solid #e0e0e0', padding='8px'))
                for col in headers[:-1]
            ] + [action_box]
            rows.append(HBox(data_cells))

        # create the table
        table = VBox(rows, layout=Layout(
            margin='20px auto',
            width='100%',
            max_width='100%'
        ))
        display(table)

"""
    Function to update the task status

    @param task_id - String : The task id
    @param new_status - String : The new status
"""
def update_task_status(task_id, new_status):
    # clear the update label
    worker_update_label.value = ""

    # get the task data
    task_data = FBconn.get('/TaskManager/', None).get(task_id)

    # if found, update the status
    if task_data:
        task_data['Status'] = new_status
        FBconn.put('/TaskManager/', task_id, task_data)

        # update the update label
        worker_update_label.value = f"Task {task_id} updated to status: {new_status}"

        # refresh the task table
        refresh_task_table()
    else:
        worker_update_label.value = f"Task {task_id} not found"

"""
    Function to get the worker's overall tasks

    @return - List : The worker's overall tasks
"""
def get_worker_tasks():
    worker_tasks = []

    # get overall task data
    data = FBconn.get('/TaskManager/', None) or {}

    # add all tasks of the logged in user
    for task_id, task_data in data.items():
        if task_data['Assigned_To'].lower() == logged_user['user']['name'].lower():
            task_data['Task ID'] = task_id
            worker_tasks.append(task_data)
    return worker_tasks

tab9_content = Output()
with tab9_content:
    # style update label
    worker_update_label = Label(text="", layout=Layout(text_align='center', font_size='16px',
                font_weight='bold', margin='10px 0 20px 0'))

    worker_task_output = Output()

    # filter by status
    worker_filter_status = Dropdown(options=["All", "To Do", "In Progress", "Done"], value="All", description="Status:")
    worker_filter_status.observe(worker_refresh_task_table, names='value')

    # filter by priority
    worker_filter_priority = Dropdown(options=["All", "Low", "Medium", "High"], value="All", description="Priority:")
    worker_filter_priority.observe(worker_refresh_task_table, names='value')

    # style overall tab
    worker_task_display =VBox([
            Label("üóÇÔ∏è My Tasks", layout=Layout(text_align='center', font_size='20px',
                font_weight='bold', margin='10px 0 20px 0')),
            HBox([worker_filter_status, worker_filter_priority],
                layout=Layout(justify_content='center', margin='10px 0')),
            worker_task_output,
            worker_update_label
        ], layout=Layout(width='100%', padding='20px', max_width='100%',
            background_color='#ffffff', border_radius='8px'))

    display(worker_task_display)

"""# **Tab 10 - My Sensors Page**"""

# Tab 10 - My Sensors

"""
    Function to refresh the worker's sensors
"""
def refresh_worker_sensors():
    global shown_sensors
    global indoor_cards
    global outdoor_cards
    global shown_sensor_widgets
    global shown_sensor_titles

    # clear the cards
    indoor_cards.clear()
    outdoor_cards.clear()
    shown_sensor_widgets.clear()
    shown_sensor_titles.clear()
    shown_sensors = {}

    # get the shown sensors
    shown_sensors = get_shown_sensors()

    # create the indoor cards
    for sensor in shown_sensors["indoor"]:
        card = worker_shown_sensor_card(sensor["type"], sensor["icon"], "indoor")
        indoor_cards.append(card)

    # create the outdoor cards
    for sensor in shown_sensors["outdoor"]:
        card = worker_shown_sensor_card(sensor["type"], sensor["icon"], "outdoor")
        outdoor_cards.append(card)

    # load the shown sensors
    load_my_sensors(shown_sensors)

    # create the indoor grid
    shown_indoor_grid = widgets.GridBox(
        children=indoor_cards,
        layout=widgets.Layout(grid_template_columns='repeat(2, 1fr)', gap="20px")
    )

    # create the outdoor grid
    shown_outdoor_grid = widgets.GridBox(
        children=outdoor_cards,
        layout=widgets.Layout(grid_template_columns='repeat(2, 1fr)', gap="20px")
    )

    def refresh_sensors_handler(b):
        refresh_worker_sensors()

    # create refresh button
    refresh_button = widgets.Button(description="Refresh", icon="refresh")
    refresh_button.on_click(refresh_sensors_handler)

    # display the overall tab
    with tab10_content:
        clear_output()

        overall_layout = widgets.VBox([
            widgets.HTML("<h2 style='margin:0;color:gray'>üè† Indoor Sensors</h2>"),
            shown_indoor_grid,
            widgets.HTML("<h2 style='margin:0;color:gray'>üå§Ô∏è Outdoor Sensors</h2>"),
            shown_outdoor_grid,
            refresh_button
        ])

        display(overall_layout)

"""
    Function to load worker's sensors

    @param shown_sensors - List : The shown sensors
"""
def load_my_sensors(shown_sensors):
    # plot all indoor sensors
    for sensor in shown_sensors["indoor"]:
        key = f"indoor_{sensor['type']}"
        if sensor["values"]:
            x, y = zip(*sensor["values"])
            plot_shown_sensor(key, sensor["type"], x, y)

    # plot all outdoor sensors
    for sensor in shown_sensors["outdoor"]:
        key = f"outdoor_{sensor['type']}"
        if sensor["values"]:
            x, y = zip(*sensor["values"])
            plot_shown_sensor(key, sensor["type"], x, y)
"""
    Function to create the sensor card

    @param sensor_type - String : The sensor type
    @param icon - String : The sensor icon
    @param location - String : The sensor location
    @return - Widget : The sensor card
"""
def worker_shown_sensor_card(sensor_type, icon, location):
    # sensor retrieval key
    key = f"{location}_{sensor_type}"

    # get the unit of the sensor
    unit = SENSOR_UNITS.get(sensor_type, "")

    # create the title for the sensor
    title = widgets.HTML(f"<h4 style='margin:0;color:gray'>{icon} {sensor_type} (-- {unit})</h4>")
    shown_sensor_titles[key] = title

    # create the graph for the sensor
    graph = widgets.Output()
    shown_sensor_widgets[key] = graph

    # create the sensor card
    worker_sensor_card = widgets.VBox([title, graph], layout=widgets.Layout(
        border="1px solid lightgray", padding="10px",
        border_radius="12px", width="100%", height="330px"))
    return worker_sensor_card

"""
    Function to plot the shown worker's sensor

    @param key - String : The sensor key
    @param sensor_type - String : The sensor type
    @param x - List : The x values
    @param y - List : The y values
"""
def plot_shown_sensor(key, sensor_type, x, y):
    # no data check
    if not y:
        shown_sensor_titles[key].value = f"<h4 style='margin:0;color:gray'>{sensor_type} (-- {SENSOR_UNITS[sensor_type]})</h4>"
        return

    # calculate the average of the sensor
    avg = sum(y) / len(y)

    # determine the color of the sensor
    color = '#FF3232' if avg < IRREGULAR_THRESHOLDS[sensor_type][0] or avg > IRREGULAR_THRESHOLDS[sensor_type][1] else '#00C717'

    # get the last value of the sensor
    latest_value = y[-1]

    # update the title of the sensor
    shown_sensor_titles[key].value = f"<h3 style='margin:0;color:gray'>{sensor_type} ({latest_value} {SENSOR_UNITS[sensor_type]})</h3>"

    # plot the sensor
    with shown_sensor_widgets[key]:
        clear_output(wait=True)
        fig, ax = plt.subplots(figsize=(4.5, 2.5))
        ax.plot(range(len(x)), y, color=color, linewidth=2, marker='o')
        ax.set_xticks(range(len(x)))
        ax.set_xticklabels(x, rotation=30)
        ax.grid(True)
        plt.tight_layout()
        plt.show()
        plt.close()

"""
    Function to get the shown worker's sensors

    @return - Dict : The shown sensors
"""
def get_shown_sensors():
    # create a copy of the indoor and outdoor sensors
    result = {"indoor": indoor_sensors.copy(), "outdoor": outdoor_sensors.copy()}

    try:
        # get the overall sensors
        data = FBconn.get('/Sensors/', None)
        if data:
            # loop through the locations
            for location in ['indoor', 'outdoor']:
                if location in data:
                    # filter the sensors by the shown sensors
                    result[location] = [
                        sensor for sensor in result[location]
                        if sensor["type"] in data[location] and data[location][sensor["type"]]["isShow"]
                    ]
    except Exception as e:
        print(f"Error getting shown sensors: {e}")
    return result

tab10_content = Output()
with tab10_content:
    indoor_cards = []
    outdoor_cards = []
    shown_sensor_widgets = {}
    shown_sensor_titles = {}
    refresh_worker_sensors()

"""# **Run All Pages**"""

tab_title_map = {
    "Dashboard": tab1_content,
    "Tasks Manager": tab6_content,
    "Search": tab2_content,
    "Statistics": tab3_content,
    "Overall Sensors": tab5_content,
    "Store": tab7_content,
    "Login": tab8_content,
    "My Tasks": tab9_content,
    "My Sensors": tab10_content,
}

show_tabs(logged_user)